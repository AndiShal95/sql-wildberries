-- ДЗ
-- 01
-- На примере из документации.
-- Сделать новую колонку в массиве, которая будет суммой чисел предыдущего элемента и текущего.
-- Ответ: [[3,1],[4,3],[5,5]]
SELECT arrayMap(x -> (x + 2), [1, 2, 3]) as arr,
	   arrayMap(x -> (x + 2), [-1, 1, 3]) as arr2,    --Сумма предыдущего и текущего??
	   arrayMap((x, y) -> (x, y), arr, arr2) as res;  -- Да, был пример на лекции где мы использовали предыдущий и текущий элемент массива.
	   
	   
-- 02
-- Из подобного массива получить новый массив: сколько секунд прошло между датами соседних элементов.
select position_id
    , arrayFilter(x -> x.1 != 0, arr_src_second) arr_new
    , arrayMap(x -> (date_diff('second', arr[x - 1].1, arr[x].1), arr[x], (toDateTime(0),0)), arrayEnumerate(arr)) arr_src_second  
    , arraySort(groupArray((dt, status_id))) arr
from tmp.table_05
group by position_id;

-- Это твой результат. Нужны небольшие правки:
[(1666965661,('2022-10-28 14:01:01',18),('1970-01-01 00:00:00',0)),(250,('2022-10-28 14:05:11',23),('1970-01-01 00:00:00',0)),(1707,('2022-10-28 14:33:38',23),('1970-01-01 00:00:00',0)),(307,('2022-10-28 14:38:45',23),('1970-01-01 00:00:00',0)),(1223,('2022-10-28 14:59:08',23),('1970-01-01 00:00:00',0)),(375,('2022-10-28 15:05:23',23),('1970-01-01 00:00:00',0)),(2771,('2022-10-28 15:51:34',23),('1970-01-01 00:00:00',0)),(21,('2022-10-28 15:51:55',23),('1970-01-01 00:00:00',0)),(276,('2022-10-28 15:56:31',23),('1970-01-01 00:00:00',0)),(4219,('2022-10-28 17:06:50',23),('1970-01-01 00:00:00',0)),(3665,('2022-10-28 18:07:55',23),('1970-01-01 00:00:00',0)),(3799,('2022-10-28 19:11:14',23),('1970-01-01 00:00:00',0)),(4611,('2022-10-28 20:28:05',23),('1970-01-01 00:00:00',0)),(316,('2022-10-28 20:33:21',23),('1970-01-01 00:00:00',0)),(12902,('2022-10-29 00:08:23',23),('1970-01-01 00:00:00',0)),(47887,('2022-10-29 13:26:30',25),('1970-01-01 00:00:00',0)),(25218,('2022-10-29 20:26:48',27),('1970-01-01 00:00:00',0)),(46,('2022-10-29 20:27:34',25),('1970-01-01 00:00:00',0)),(1125,('2022-10-29 20:46:19',27),('1970-01-01 00:00:00',0)),(21,('2022-10-29 20:46:40',25),('1970-01-01 00:00:00',0)),(16606,('2022-10-30 01:23:26',27),('1970-01-01 00:00:00',0))]

-- Это правильный результат:
[1666965661,250,1707,307,1223,375,2771,21,276,4219,3665,3799,4611,316,12902,47887,25218,46,1125,21,16606]


-- 03
-- Найти сотрудника с большим кол-вом проходов по турнику и для него получить данные.
-- Посчитать начало смены через массив. Должен получиться массив с началом смен.
-- Также добавить колонку конец смены. Должен получиться массив с окончанием смен.
-- Начало смены считаем так: is_in = 0, через 7 или более часов был вход. Этот вход и есть начало смены.
-- Конец смены считаем аналогично.
-- За исходник кода можно взять этот запрос и поправить его.
select position_id
    , arrayFilter(x -> x.1 != 0, arr_src) arr_new
    , arrayMap(x -> (if(date_diff('hour',arr[x - 1].1, arr[x].1) > 7, arr[x], (toDateTime(0),0))), arrayEnumerate(arr)) arr_src
    , arraySort(groupArray((dt, status_id))) arr
from tmp.table_05
group by position_id

